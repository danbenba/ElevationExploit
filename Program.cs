using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.IO.Compression;
using System.Net;
using System.Reflection;

namespace ElevationExample
{
    class Program
    {
        // Indique si on écrit dans un fichier .log
        private static bool _logToFile = false;

        // Chemin du fichier de logs
        private static string _logFilePath = "";

        // URL par défaut d’AdvancedRun
        private static string _advancedRunUrl = "https://github.com/danbenba/ElevationExploit/raw/refs/heads/project/AdvancedRun.zip";

        // Par défaut, on prend le mode 8 (TrustedInstaller)
        private static int _runAsMode = 8;

        // Arguments supplémentaires passés à la commande (remplace qrg par arg)
        private static string _additionalArguments = "";

        // Indique si on veut utiliser AdvancedRun (télécharger, etc.)
        private static bool _downloadAdvancedRun = false;

        // Dictionnaire des modes (pour logs)
        private static readonly Dictionary<int, string> _runAsDescriptions = new Dictionary<int, string>
        {
            {1,  "Utilisateur actuel - Autoriser élévation (LIAC)"},
            {2,  "Utilisateur actuel - Sans élévation (IJAC)"},
            {3,  "Administrateur (Forcer élévation)"},
            {4,  "Utilisateur SYSTEM"},
            {5,  "Utilisateur du processus sélectionné"},
            {6,  "Descendant du processus sélectionné (Injection code)"},
            {7,  "Nom d’utilisateur + mot de passe (spécifiés)"},
            {8,  "TrustedInstaller"},
            {9,  "Autre utilisateur connecté"},
            {10, "Service réseau"},
            {11, "Service local"}
        };

        static void Main(string[] args)
        {
            // Affiche un petit "banner"
            PrintBanner();

            // Si aucun argument ou si on demande l'aide
            if (args.Length == 0 || args[0].Equals("-h", StringComparison.OrdinalIgnoreCase) 
                                 || args[0].Equals("--help", StringComparison.OrdinalIgnoreCase))
            {
                PrintHelp();
                return;
            }

            // Premièrement, la commande à exécuter (ex: cmd.exe)
            string command = args[0];

            // Analyse des options
            for (int i = 1; i < args.Length; i++)
            {
                string arg = args[i];

                if (arg.Equals("-t", StringComparison.OrdinalIgnoreCase))
                {
                    _downloadAdvancedRun = true;
                }
                else if (arg.Equals("-s", StringComparison.OrdinalIgnoreCase))
                {
                    _logToFile = true;
                }
                else if (arg.Equals("-e", StringComparison.OrdinalIgnoreCase))
                {
                    if (i + 1 < args.Length)
                    {
                        _logFilePath = args[++i];
                        _logToFile = true;
                    }
                }
                else if (arg.Equals("-u", StringComparison.OrdinalIgnoreCase))
                {
                    if (i + 1 < args.Length)
                    {
                        _advancedRunUrl = args[++i];
                    }
                }
                else if (arg.Equals("-m", StringComparison.OrdinalIgnoreCase))
                {
                    if (i + 1 < args.Length && int.TryParse(args[i + 1], out int mode))
                    {
                        if (mode >= 1 && mode <= 11)
                        {
                            _runAsMode = mode;
                            _downloadAdvancedRun = true;
                        }
                        i++;
                    }
                }
                // Remplacement : au lieu de -qrg => -arg
                else if (arg.Equals("-arg", StringComparison.OrdinalIgnoreCase))
                {
                    // Arguments supplémentaires
                    if (i + 1 < args.Length)
                    {
                        _additionalArguments = args[++i];
                    }
                }
            }

            // Si on doit logger dans un fichier sans -e, on utilise Elevation.log
            if (_logToFile && string.IsNullOrWhiteSpace(_logFilePath))
            {
                _logFilePath = Path.Combine(Environment.CurrentDirectory, "Elevation.log");
            }

            // Vérifie si on est admin
            if (!IsRunningAsAdmin())
            {
                RelaunchAsAdmin(args);
                return;
            }

            WriteLog("[OK] Exécuté avec droits administrateur.", LogLevel.Success);

            if (_downloadAdvancedRun)
            {
                DownloadAndRunAdvancedRun(command, _additionalArguments);
            }
            else
            {
                ExecuteCommand(command, _additionalArguments);
            }
        }

        /// <summary>
        /// Affiche un banner en console.
        /// </summary>
        private static void PrintBanner()
        {
            Console.ForegroundColor = ConsoleColor.Yellow;
            Console.WriteLine("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
            Console.WriteLine("    _____ _                 _   _               _____           _       _ _   ");
            Console.WriteLine("   |  ___| |               | | (_)             |  ___|         | |     (_) |  ");
            Console.WriteLine("   | |__ | | _____   ____ _| |_ _  ___  _ __   | |____  ___ __ | | ___  _| |_ ");
            Console.WriteLine("   |  __|| |/ _ \\ \\ / / _` | __| |/ _ \\| '_ \\  |  __\\ \\/ / '_ \\| |/ _ \\| | __|");
            Console.WriteLine("   | |___| |  __/\\ V / (_| | |_| | (_) | | | | | |___>  <| |_) | | (_) | | |_ ");
            Console.WriteLine("   \\____/|_|\\___| \\_/ \\__,_|\\__|_|\\___/|_| |_| \\____/_/\\_\\ .__/|_|\\___/|_|\\__|");
            Console.WriteLine("                                                      | |                  ");
            Console.WriteLine("                                                      |_|                  ");
            Console.WriteLine("");
            Console.WriteLine(" Version 0.4 - https://github.com/danbenba/ElevationExploit - Created by danbenba");
            Console.WriteLine("=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=");
            Console.ResetColor();
        }


        /// <summary>
        /// Affiche le menu d'aide.
        /// </summary>
        private static void PrintHelp()
        {
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine("Usage : elevation.exe <commande> [options]");
            Console.WriteLine("Exemple : elevation.exe cmd.exe -m 3 -arg \"/c dir\"");
            Console.WriteLine();
            Console.WriteLine("Options :");
            Console.WriteLine("  -t               : Mode TrustedInstaller");
            Console.WriteLine("  -m <1..11>       : Mode /RunAs (ex: 3=Admin forcé, 8=TrustedInstaller, etc.)");
            Console.WriteLine("  -arg \"args...\"   : Arguments supplémentaires passés à la commande (ex: /c dir)");
            Console.WriteLine("  -s               : Sauvegarder les logs dans un fichier .log (par défaut Elevation.log)");
            Console.WriteLine("  -e \"cheminLog\"   : Chemin personnalisé pour le fichier de log");
            Console.WriteLine("  -u \"urlZip\"      : URL personnalisée pour télécharger AdvancedRun.zip");
            Console.WriteLine();
            Console.WriteLine("  -h / --help      : Afficher cette aide");
            Console.ResetColor();
        }

        /// <summary>
        /// Vérifie si l’application est exécutée en tant qu’administrateur.
        /// </summary>
        private static bool IsRunningAsAdmin()
        {
            var wi = System.Security.Principal.WindowsIdentity.GetCurrent();
            var wp = new System.Security.Principal.WindowsPrincipal(wi);
            return wp.IsInRole(System.Security.Principal.WindowsBuiltInRole.Administrator);
        }

        /// <summary>
        /// Relance l’appli en mode admin (affiche prompt UAC).
        /// </summary>
        private static void RelaunchAsAdmin(string[] args)
        {
            string exeName = Process.GetCurrentProcess().MainModule.FileName;
            string arguments = string.Join(" ", args);

            var startInfo = new ProcessStartInfo
            {
                FileName = exeName,
                Verb = "runas",
                Arguments = arguments,
                UseShellExecute = true
            };

            try
            {
                Process.Start(startInfo);
            }
            catch (Exception ex)
            {
                WriteLog("Échec lors de la relance avec privilèges élevés : " + ex.Message, LogLevel.Error);
            }
        }

        /// <summary>
        /// Exécute directement la commande (ex : cmd.exe) avec éventuellement des arguments supplémentaires.
        /// </summary>
        private static void ExecuteCommand(string command, string extraArgs)
        {
            try
            {
                string fullCommand = command;
                if (!string.IsNullOrEmpty(extraArgs))
                {
                    fullCommand += " " + extraArgs;
                }

                WriteLog($"[INFO] Exécution directe : {fullCommand}", LogLevel.Info);
                Process.Start(fullCommand);
            }
            catch (Exception ex)
            {
                WriteLog($"[ERREUR] {ex.Message}", LogLevel.Error);
            }
        }

        /// <summary>
        /// Télécharge AdvancedRun, l’extrait, et l’exécute avec /RunAs _runAsMode.
        /// </summary>
        private static void DownloadAndRunAdvancedRun(string command, string extraArgs)
        {
            string appDataTemp = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData),
                "Temp"
            );
            Directory.CreateDirectory(appDataTemp);

            string zipFilePath = Path.Combine(appDataTemp, "AdvancedRun.zip");

            WriteLog($"[INFO] Téléchargement d'AdvancedRun.", LogLevel.Info);
            if (!DownloadFileWithProgress(_advancedRunUrl, zipFilePath))
            {
                WriteLog("[ERREUR] Échec du téléchargement.", LogLevel.Error);
                return;
            }

            WriteLog("[INFO] Téléchargement terminé.", LogLevel.Info);

            // Extraction
            try
            {
                ZipFile.ExtractToDirectory(zipFilePath, appDataTemp, true);
                WriteLog("[INFO] Décompression réussie.", LogLevel.Success);
            }
            catch (Exception ex)
            {
                WriteLog($"[ERREUR] Impossible de décompresser : {ex.Message}", LogLevel.Error);
                return;
            }

            // On affiche dans les logs le mode choisi
            if (_runAsDescriptions.TryGetValue(_runAsMode, out string desc))
            {
                WriteLog($"[+] Mode choisi : {_runAsMode} ({desc})", LogLevel.Info);
            }
            else
            {
                WriteLog($"[+] Mode choisi : {_runAsMode}", LogLevel.Info);
            }

            // On injecte éventuellement les extraArgs à la commande
            string runCommand = command;
            if (!string.IsNullOrEmpty(extraArgs))
            {
                runCommand += " " + extraArgs;
            }

            // Exécution d'AdvancedRun
            string advancedRunExe = Path.Combine(appDataTemp, "AdvancedRun.exe");

            var psi = new ProcessStartInfo
            {
                FileName = advancedRunExe,
                Arguments = $"/EXEFilename \"{runCommand}\" /RunAs {_runAsMode} /Run",
                UseShellExecute = false
            };

            try
            {
                WriteLog($"[INFO] Lancement d'AdvancedRun.exe avec : {runCommand}", LogLevel.Info);
                Process.Start(psi);
            }
            catch (Exception ex)
            {
                WriteLog("[ERREUR] Impossible de lancer AdvancedRun : " + ex.Message, LogLevel.Error);
            }
        }

        /// <summary>
        /// Télécharge un fichier, affiche une barre de progression ASCII et log chaque pourcentage.
        /// </summary>
        private static bool DownloadFileWithProgress(string url, string destinationPath)
        {
            try
            {
                using (WebClient client = new WebClient())
                {
                    // On va mémoriser le dernier pourcentage pour éviter d'écrire 100 fois le même.
                    int lastProgress = -1;

                    client.DownloadProgressChanged += (sender, e) =>
                    {
                        int progressValue = e.ProgressPercentage;

                        if (progressValue != lastProgress)
                        {
                            lastProgress = progressValue;

                            // Affichage console : barre de progression
                            DrawProgressBar(progressValue, 100);

                            // On log aussi
                            WriteLog($"[DOWNLOAD] {progressValue}%", LogLevel.Info, false);
                        }
                    };

                    client.DownloadFileCompleted += (sender, e) =>
                    {
                        Console.WriteLine(); // pour aller à la ligne après la barre

                        if (e.Cancelled)
                        {
                            WriteLog("[ANNULÉ] Téléchargement annulé.", LogLevel.Warning);
                        }
                        else if (e.Error != null)
                        {
                            WriteLog($"[ERREUR] {e.Error.Message}", LogLevel.Error);
                        }
                        else
                        {
                            WriteLog("[OK] Téléchargement réussi.", LogLevel.Success);
                        }
                    };

                    // Téléchargement bloquant (synchrone)
                    client.DownloadFile(url, destinationPath);
                }

                return true;
            }
            catch (Exception ex)
            {
                WriteLog("[ERREUR] " + ex.Message, LogLevel.Error);
                return false;
            }
        }

        /// <summary>
        /// Dessine une barre de progression (ASCII) en console.
        /// ex: [##########----] 60%
        /// </summary>
        private static void DrawProgressBar(int current, int max)
        {
            const int barLength = 30; // longueur en caractères
            double ratio = (double)current / max;
            int nbChars = (int)(ratio * barLength);

            Console.ForegroundColor = ConsoleColor.DarkCyan;
            Console.Write("\r[");  // retour en début de ligne
            Console.Write(new string('#', nbChars));
            Console.Write(new string('-', barLength - nbChars));
            Console.Write($"] {current}%");
            Console.ResetColor();
        }

        // --- SYSTÈME DE LOGS ---

        /// <summary>
        /// Niveaux de log : Info, Succès, Erreur, Avertissement.
        /// </summary>
        enum LogLevel
        {
            Info,
            Success,
            Error,
            Warning
        }

        /// <summary>
        /// Écrit un message dans la console (avec couleur) + fichier log si demandé.
        /// Le paramètre "logToConsoleOverride" permet de forcer ou non l'affichage console.
        /// </summary>
        static void WriteLog(string message, LogLevel level, bool logToConsoleOverride = true)
        {
            // Si on veut afficher en console
            if (logToConsoleOverride)
            {
                ConsoleColor oldColor = Console.ForegroundColor;
                switch (level)
                {
                    case LogLevel.Info:
                        Console.ForegroundColor = ConsoleColor.White;
                        break;
                    case LogLevel.Success:
                        Console.ForegroundColor = ConsoleColor.Green;
                        break;
                    case LogLevel.Error:
                        Console.ForegroundColor = ConsoleColor.Red;
                        break;
                    case LogLevel.Warning:
                        Console.ForegroundColor = ConsoleColor.Yellow;
                        break;
                }

                // Écrit en console
                Console.WriteLine(message);
                Console.ForegroundColor = oldColor;
            }

            // Écrit dans un fichier .log si activé
            if (_logToFile && !string.IsNullOrWhiteSpace(_logFilePath))
            {
                try
                {
                    using (var sw = new StreamWriter(_logFilePath, true))
                    {
                        sw.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
                    }
                }
                catch (Exception ex)
                {
                    // Si on échoue à écrire, on l’affiche en console
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("[ERREUR-LOG] " + ex.Message);
                    Console.ResetColor();
                }
            }
        }
    }
}
